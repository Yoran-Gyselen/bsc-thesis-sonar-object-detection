\chapter{Data}
\label{ch:data}

Data is de backbone van dit onderzoek. Daarom is het belangrijk een betrouwbare en kwalitatieve dataset te gebruiken. Zoals eerder vermeld zal de UATD-dataset gebruikt worden. \\

%TODO
TODO: verder uitschrijven

\subsection{Herschalen van de afbeeldingen}

De meeste deep learning-modellen verwachten een input met consistente dimensies. 

\begin{listing}[H]
    \begin{minted}{python}
        def resize_image(image, target_size=(1024, 1024)):
            h, w = image.shape
            target_h, target_w = target_size
            
            # Calculate scaling factor
            scale = min(target_w / w, target_h / h)
            new_w = int(w * scale)
            new_h = int(h * scale)
            
            # Resize the image
            resized_image = cv2.resize(image, (new_w, new_h))
            
            # Create a new blank image with the target size
            new_image = np.zeros((target_h, target_w), dtype=np.uint8)
            
            # Calculate the padding
            pad_w = (target_w - new_w) // 2
            pad_h = (target_h - new_h) // 2
            
            # Place the resized image in the center of the new image
            new_image[pad_h:pad_h + new_h, pad_w:pad_w + new_w] = resized_image
            
            return new_image, (pad_w, pad_h, new_w, new_h)
    \end{minted}
    \caption[Functie \texttt{resize\_image}]{Functie die ervoor zorgt dat de afbeelding correct herschaald wordt en dat er \emph{padding} wordt toegevoegd om een afbeelding met consistente dimensies te bekomen.}
\end{listing}

% TODO: afbeelding toevoegen voor en na deze functie

De functie \texttt{resize\_image} past de grootte van een afbeelding aan en plaatst deze gecentreerd in een nieuw canvas met een vaste afmeting. De standaard \texttt{target\_size} is $1024 \times 1024$ pixels, maar dit kan worden aangepast. De functie gebruikt OpenCV (\texttt{cv2.resize}) om de afbeelding proportioneel te schalen, zodat deze in het doelcanvas past zonder de beeldverhouding te veranderen. \\

Eerst wordt de hoogte en breedte van de oorspronkelijke afbeelding bepaald, evenals de doelhoogte en -breedte. Vervolgens wordt een schaalfactor berekend op basis van de kleinste verhouding tussen de doelafmetingen en de oorspronkelijke afmetingen. De afbeelding wordt met deze schaalfactor aangepast, zodat deze zo groot mogelijk binnen de doelafmetingen past. \\

Daarna wordt een nieuw, zwart canvas aangemaakt met de doelgrootte. De berekende padding aan de randen zorgt ervoor dat de geschaalde afbeelding gecentreerd wordt geplaatst binnen dit canvas. Ten slotte retourneert de functie zowel de nieuw gecreëerde afbeelding als de padding-waarden, zodat men indien nodig de positie en grootte van de originele afbeelding in het nieuwe canvas kan achterhalen.

%TODO: beeldverhouding need gls

\subsection{Herberekenen van bounding boxes}

De functie \texttt{resize\_image} zorgt ervoor dat alle afbeeldingen herschaald worden naar consistente dimensies. Dit zorgt er echter voor dat de posities van de \glspl{bounding_box} niet meer kloppen. De volgende functie herberekent de \glspl{bounding_box}, rekening houdend met de herschaling en padding.

\begin{listing}[H]
    \begin{minted}{python}
        def convert_bounding_boxes(bboxes, padding, original_size, new_size=(1024, 1024)):
            pad_w, pad_h, new_core_w, new_core_h = padding
            init_img_w, init_img_h = original_size
            total_w, total_h = new_size
            
            normalized_bboxes = []
            
            for bbox in bboxes:
                x_min, y_min, x_max, y_max = bbox
                
                # Adjust for padding
                x_min = (x_min * new_core_w) / init_img_w + pad_w
                x_max = (x_max * new_core_w) / init_img_w + pad_w
                y_min = (y_min * new_core_h) / init_img_h + pad_h
                y_max = (y_max * new_core_h) / init_img_h + pad_h
                
                # Calculate the center and size of the bounding box
                bbox_width_in_px = x_max - x_min
                bbox_height_in_px = y_max - y_min
                x_center_in_px = x_min + bbox_width_in_px / 2
                y_center_in_px = y_min + bbox_height_in_px / 2
                
                # Normalize the coordinates
                x_norm = x_center_in_px / total_w
                y_norm = y_center_in_px / total_h
                bbox_width_norm = bbox_width_in_px / total_w
                bbox_height_norm = bbox_height_in_px / total_h
                
                normalized_bboxes.append((x_norm, y_norm, bbox_width_norm, bbox_height_norm))
            
            return normalized_bboxes
    \end{minted}
    \caption[Functie \texttt{convert\_bounding\_boxes}]{Functie die ervoor zorgt dat de \glspl{bounding_box} herberekend worden nadat de afbeelding herschaald is door \texttt{resize\_image}.}
\end{listing}

De functie \texttt{convert\_bounding\_boxes}, past de coördinaten van bestaande \glspl{bounding_box} aan nadat een afbeelding is geschaald en gecentreerd in een nieuw canvas. Dit is nodig omdat bij het aanpassen van de afbeelding de objectlocaties in de oorspronkelijke afbeelding niet langer direct overeenkomen met hun nieuwe positie in het vergrote of verkleinde en verschoven beeld. De \glspl{bounding_box} worden ook genormaliseerd, zodat ze geschikt zijn voor modellen die werken met schaalonafhankelijke coördinaten (bv. \gls{yolo}). \\

De functie ontvangt een lijst van \glspl{bounding_box}, de paddingwaarden van de afbeeldingstransformatie, de oorspronkelijke afbeeldingsgrootte en de nieuwe grootte (standaard $1024 \times 1024$ pixels). Voor elke \gls{bounding_box} worden de oorspronkelijke coördinaten aangepast aan de nieuwe afmetingen. Dit gebeurt door eerst de verhoudingen tussen de oude en nieuwe breedte en hoogte toe te passen en vervolgens de padding toe te voegen. Hierdoor worden de coördinaten correct in het nieuwe canvas geplaatst.

Daarna worden de aangepaste \gls{bounding_box}-coördinaten omgezet naar een gecentreerde representatie. Dit betekent dat de functie de breedte en hoogte van de box berekent en het middelpunt bepaalt. Vervolgens worden deze waarden genormaliseerd door ze te delen door de totale breedte en hoogte van het nieuwe beeld. Dit maakt de bounding box coördinaten onafhankelijk van de werkelijke afbeeldingsgrootte, waardoor ze compatibel zijn met (verschillende veelgebruikte) deep learning-modellen. De functie retourneert een lijst met genormaliseerde \glspl{bounding_box}, elk voorgesteld als \texttt{(x\_center, y\_center, width, height)}.